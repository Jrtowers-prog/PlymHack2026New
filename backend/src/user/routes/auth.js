/**
 * auth.js — Authentication routes (magic link / passwordless).
 *
 * POST /api/auth/magic-link   — Send magic link email
 * POST /api/auth/verify       — Exchange OTP token for session
 * POST /api/auth/refresh       — Refresh expired access token
 * GET  /api/auth/me            — Get current user profile
 * POST /api/auth/update-profile — Update user name/platform/version
 * POST /api/auth/logout        — Sign out (invalidate token)
 */

const express = require('express');
const { supabase } = require('../lib/supabase');
const { requireAuth } = require('../middleware/authMiddleware');

const router = express.Router();

// ─── Ensure all required DB records exist for a user ─────────────────────────
// Idempotent — safe to call on every login. Creates profile, default
// subscription, and first usage event if they don't already exist.
async function ensureUserRecords(userId, email, name) {
  try {
    // 1. Profile — upsert (create if missing, otherwise just update last_seen + email)
    const { data: existingProfile } = await supabase
      .from('profiles')
      .select('id')
      .eq('id', userId)
      .maybeSingle();

    if (!existingProfile) {
      await supabase.from('profiles').insert({
        id: userId,
        email: email || null,
        name: name || '',
        created_at: new Date().toISOString(),
        last_seen_at: new Date().toISOString(),
      });
    } else {
      // Only update last_seen and fill in email if it was missing
      await supabase
        .from('profiles')
        .update({
          last_seen_at: new Date().toISOString(),
          ...(email ? { email } : {}),
        })
        .eq('id', userId);
    }

    // 2. Default free subscription (only if none exists)
    const { data: existingSub } = await supabase
      .from('subscriptions')
      .select('id')
      .eq('user_id', userId)
      .limit(1)
      .maybeSingle();

    if (!existingSub) {
      await supabase.from('subscriptions').insert({
        user_id: userId,
        tier: 'free',
        status: 'active',
      });
    }

    // 3. Log account_created event (only if never logged)
    const { data: existingEvent } = await supabase
      .from('usage_events')
      .select('id')
      .eq('user_id', userId)
      .eq('event_type', 'account_created')
      .limit(1)
      .maybeSingle();

    if (!existingEvent) {
      await supabase.from('usage_events').insert({
        user_id: userId,
        event_type: 'account_created',
        value_text: 'signup',
      });
    }

    console.log(`[auth] ensureUserRecords OK for ${userId}`);
  } catch (err) {
    // Non-fatal — log but don't block login
    console.error('[auth] ensureUserRecords error:', err.message);
  }
}

// ─── Strict rate limit for sensitive auth endpoints ──────────────────────────
// magic-link + verify only — prevents brute-force OTP guessing & email spam.
// Uses ipOnly because there's no JWT yet at sign-in time.
const authSensitiveLimit = require('../../../shared/middleware/rateLimiter').createRateLimiter({
  windowMs: 15 * 60 * 1000,
  max: 20,         // 20 per IP per 15 min (plenty for real users, blocks abuse)
  ipOnly: true,
});

// ─── Validation helpers ──────────────────────────────────────────────────────
const EMAIL_RE = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
const MAX_NAME = 100;
const VALID_PLATFORMS = ['android', 'ios', 'web'];

function validateEmail(email) {
  if (!email || typeof email !== 'string') return false;
  return EMAIL_RE.test(email.trim().toLowerCase());
}

// ─── POST /api/auth/magic-link ───────────────────────────────────────────────
// Send a passwordless magic link to the user's email.
// If the user doesn't exist, Supabase creates them automatically.
router.post('/magic-link', authSensitiveLimit, async (req, res, next) => {
  try {
    const { email, name } = req.body;

    if (!validateEmail(email)) {
      return res.status(400).json({ error: 'Valid email is required' });
    }

    const cleanEmail = email.trim().toLowerCase();
    const cleanName = typeof name === 'string' ? name.trim().slice(0, MAX_NAME) : '';

    const { error } = await supabase.auth.signInWithOtp({
      email: cleanEmail,
      options: {
        data: { name: cleanName },
        shouldCreateUser: true,
      },
    });

    if (error) {
      console.error('[auth] Magic link error:', error.message, error.status, JSON.stringify(error));
      return res.status(400).json({ error: error.message || 'Failed to send magic link' });
    }

    res.json({ message: 'Magic link sent — check your email' });
  } catch (err) {
    next(err);
  }
});

// ─── POST /api/auth/verify ──────────────────────────────────────────────────
// Exchange OTP token (from magic link URL) for a session.
router.post('/verify', authSensitiveLimit, async (req, res, next) => {
  try {
    const { token, email } = req.body;

    if (!token || typeof token !== 'string') {
      return res.status(400).json({ error: 'Token is required' });
    }
    if (!validateEmail(email)) {
      return res.status(400).json({ error: 'Valid email is required' });
    }

    const cleanEmail = email.trim().toLowerCase();

    const { data, error } = await supabase.auth.verifyOtp({
      email: cleanEmail,
      token,
      type: 'email',
    });

    if (error || !data.session) {
      console.error('[auth] Verify OTP error:', error?.message);
      return res.status(401).json({ error: 'Invalid or expired token' });
    }

    // ── Ensure all required DB records exist (safety net) ─────────
    // The DB trigger handles this on first signup, but if the schema
    // was recreated or the trigger failed, this catches it.
    await ensureUserRecords(data.user.id, data.user.email, data.user.user_metadata?.name);

    // Update last_seen
    await supabase
      .from('profiles')
      .update({ last_seen_at: new Date().toISOString() })
      .eq('id', data.user.id);

    res.json({
      access_token: data.session.access_token,
      refresh_token: data.session.refresh_token,
      expires_in: data.session.expires_in,
      user: {
        id: data.user.id,
        email: data.user.email,
      },
    });
  } catch (err) {
    next(err);
  }
});

// ─── POST /api/auth/refresh ─────────────────────────────────────────────────
// Refresh an expired access token using a refresh token.
router.post('/refresh', async (req, res, next) => {
  try {
    const { refresh_token } = req.body;

    if (!refresh_token || typeof refresh_token !== 'string') {
      return res.status(400).json({ error: 'Refresh token is required' });
    }

    const { data, error } = await supabase.auth.refreshSession({
      refresh_token,
    });

    if (error || !data.session) {
      return res.status(401).json({ error: 'Invalid or expired refresh token' });
    }

    res.json({
      access_token: data.session.access_token,
      refresh_token: data.session.refresh_token,
      expires_in: data.session.expires_in,
    });
  } catch (err) {
    next(err);
  }
});

// ─── GET /api/auth/me ────────────────────────────────────────────────────────
// Get the current user's profile (requires auth).
router.get('/me', requireAuth, async (req, res, next) => {
  try {
    // Ensure records exist (covers edge case: schema recreated after signup)
    await ensureUserRecords(req.user.id, req.user.email);

    const { data, error } = await supabase
      .from('profiles')
      .select('id, email, name, username, push_token, platform, app_version, subscription, onboarded, disclaimer_accepted_at, created_at, last_seen_at')
      .eq('id', req.user.id)
      .single();

    if (error || !data) {
      return res.status(404).json({ error: 'Profile not found' });
    }

    // Update last_seen
    await supabase
      .from('profiles')
      .update({ last_seen_at: new Date().toISOString() })
      .eq('id', req.user.id);

    // Fetch active subscription details
    const { data: sub } = await supabase
      .from('subscriptions')
      .select('id, tier, status, started_at, expires_at')
      .eq('user_id', req.user.id)
      .eq('status', 'active')
      .order('started_at', { ascending: false })
      .limit(1)
      .maybeSingle();

    // Fetch contact counts
    const { count: contactCount } = await supabase
      .from('emergency_contacts')
      .select('id', { count: 'exact', head: true })
      .eq('status', 'accepted')
      .or(`user_id.eq.${req.user.id},contact_id.eq.${req.user.id}`);

    res.json({
      ...data,
      email: data.email || req.user.email,
      subscription_details: sub || { tier: 'free', status: 'active' },
      contact_count: contactCount || 0,
    });
  } catch (err) {
    next(err);
  }
});

// ─── POST /api/auth/accept-disclaimer ───────────────────────────────────────
// Record that the user has accepted the safety disclaimer.
// Idempotent — if already accepted, returns success without overwriting.
router.post('/accept-disclaimer', requireAuth, async (req, res, next) => {
  try {
    // Only set if not already accepted (preserve original acceptance time)
    const { data: profile } = await supabase
      .from('profiles')
      .select('disclaimer_accepted_at')
      .eq('id', req.user.id)
      .single();

    if (profile?.disclaimer_accepted_at) {
      return res.json({ message: 'Already accepted', accepted_at: profile.disclaimer_accepted_at });
    }

    const now = new Date().toISOString();
    const { error } = await supabase
      .from('profiles')
      .update({ disclaimer_accepted_at: now })
      .eq('id', req.user.id);

    if (error) {
      console.error('[auth] Disclaimer accept error:', error.message);
      return res.status(500).json({ error: 'Failed to save disclaimer acceptance' });
    }

    res.json({ message: 'Disclaimer accepted', accepted_at: now });
  } catch (err) {
    next(err);
  }
});

// ─── POST /api/auth/update-profile ──────────────────────────────────────────
// Update name, platform, app_version, push_token, onboarded.
router.post('/update-profile', requireAuth, async (req, res, next) => {
  try {
    const updates = {};
    const { name, platform, app_version, push_token, onboarded } = req.body;

    if (typeof name === 'string') {
      updates.name = name.trim().slice(0, MAX_NAME);
    }
    if (typeof platform === 'string' && VALID_PLATFORMS.includes(platform)) {
      updates.platform = platform;
    }
    if (typeof app_version === 'string' && app_version.length <= 20) {
      updates.app_version = app_version;
    }
    if (typeof push_token === 'string' && push_token.length <= 200) {
      updates.push_token = push_token;
    }
    if (typeof onboarded === 'boolean') {
      updates.onboarded = onboarded;
    }

    if (Object.keys(updates).length === 0) {
      return res.status(400).json({ error: 'No valid fields to update' });
    }

    updates.last_seen_at = new Date().toISOString();

    const { error } = await supabase
      .from('profiles')
      .update(updates)
      .eq('id', req.user.id);

    if (error) {
      console.error('[auth] Profile update error:', error.message);
      return res.status(500).json({ error: 'Failed to update profile' });
    }

    res.json({ message: 'Profile updated' });
  } catch (err) {
    next(err);
  }
});

// ─── POST /api/auth/logout ──────────────────────────────────────────────────
router.post('/logout', requireAuth, async (req, res, next) => {
  try {
    // Server-side sign out — invalidates the user's session
    const { error } = await supabase.auth.admin.signOut(req.user.id);

    if (error) {
      console.error('[auth] Logout error:', error.message);
    }

    res.json({ message: 'Logged out' });
  } catch (err) {
    next(err);
  }
});

module.exports = router;
