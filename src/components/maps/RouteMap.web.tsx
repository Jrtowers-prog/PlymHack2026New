/**
 * RouteMap.web — Leaflet + OpenStreetMap tiles (100 % free, no API key).
 *
 * Replaces Google Maps JS SDK entirely.  All features preserved:
 *   – Route polylines (safety-coloured segments)
 *   – Safety markers (crime, shop, light, bus_stop)
 *   – Road labels, navigation mode, pan-to, long-press, click handlers
 *   – Map type switching (roadmap / satellite / hybrid / terrain)
 */
import { useEffect, useRef, useState } from 'react';
import { StyleSheet, Text, View } from 'react-native';

import type { MapType, RouteMapProps } from '@/src/components/maps/RouteMap.types';

// ── Tile URLs for different map styles (all free / no key) ───────────────────

const TILE_URLS: Record<MapType, string> = {
  roadmap: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
  satellite:
    'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
  hybrid:
    'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
  terrain: 'https://tile.opentopomap.org/{z}/{x}/{y}.png',
};

const TILE_ATTR: Record<MapType, string> = {
  roadmap:
    '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
  satellite: '&copy; Esri, Maxar, Earthstar Geographics',
  hybrid:
    '&copy; Esri | &copy; <a href="https://www.openstreetmap.org/copyright">OSM</a>',
  terrain:
    '&copy; <a href="https://opentopomap.org">OpenTopoMap</a>',
};

// ── Build Leaflet HTML page (embedded in iframe blob) ────────────────────────

const buildLeafletHtml = () => `<!DOCTYPE html>
<html><head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"><\/script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden}
#viewport{width:100%;height:100%;overflow:hidden;position:relative}
#map{width:100%;height:100%;transition:transform 0.5s ease-out;transform-origin:center 65%}
.nav-arrow{background:none;border:none}
.map-ctrl{position:absolute;right:12px;bottom:100px;z-index:1000;display:flex;flex-direction:column;gap:4px}
.map-btn{width:38px;height:38px;border:none;border-radius:8px;background:rgba(255,255,255,.95);
  box-shadow:0 2px 8px rgba(0,0,0,.2);font-size:20px;font-weight:700;color:#1D2939;
  cursor:pointer;display:flex;align-items:center;justify-content:center;user-select:none;line-height:1}
.map-btn:hover{background:#e4e7ec}
.recenter-btn{position:absolute;right:12px;bottom:50px;z-index:1000;width:38px;height:38px;
  border:none;border-radius:50%;background:rgba(255,255,255,.95);
  box-shadow:0 2px 8px rgba(0,0,0,.2);cursor:pointer;display:none;align-items:center;justify-content:center}
.recenter-btn:hover{background:#e4e7ec}
.road-label{background:rgba(0,0,0,.7);color:#fff;padding:2px 8px;border-radius:9px;
  font-size:9px;font-weight:600;white-space:nowrap;border:none;box-shadow:none}
</style>
</head><body>
<div id="viewport">
<div id="map"></div>
<div class="map-ctrl">
<button class="map-btn" onclick="map.zoomIn()">+</button>
<button class="map-btn" onclick="map.zoomOut()">&minus;</button>
</div>
<button class="recenter-btn" id="recenterBtn" onclick="recenterMap()">
<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#1D2939" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><line x1="12" y1="2" x2="12" y2="5"/><line x1="12" y1="19" x2="12" y2="22"/><line x1="2" y1="12" x2="5" y2="12"/><line x1="19" y1="12" x2="22" y2="12"/></svg>
</button>
</div>
<script>
var map,tileLayer,markers=[],polylines=[],navMarker=null,longPressTimer=null,longPressLatLng=null;
var isNavMode=false,currentRotation=0,userInteracted=false,lastNavLL=null;
var rangeCircle=null;

function clearArr(a){for(var i=0;i<a.length;i++)map.removeLayer(a[i]);a.length=0;}

function sendMsg(t,d){
  try{var m=Object.assign({type:t},d||{});
    window.parent.postMessage(JSON.stringify(m),'*');
    window.dispatchEvent(new CustomEvent('leaflet-msg',{detail:m}));
  }catch(e){}
}

map=L.map('map',{center:[50.3755,-4.1427],zoom:13,zoomControl:false,attributionControl:true});
tileLayer=L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png',{
  attribution:'&copy; OpenStreetMap',maxZoom:19}).addTo(map);

map.on('contextmenu',function(e){sendMsg('longpress',{lat:e.latlng.lat,lng:e.latlng.lng});});
var touchStart=null;
map.on('mousedown',function(e){touchStart=Date.now();longPressLatLng=e.latlng;
  longPressTimer=setTimeout(function(){if(longPressLatLng)sendMsg('longpress',{lat:longPressLatLng.lat,lng:longPressLatLng.lng});},600);});
map.on('mousemove',function(){if(longPressTimer){clearTimeout(longPressTimer);longPressTimer=null;}});
map.on('mouseup',function(){if(longPressTimer){clearTimeout(longPressTimer);longPressTimer=null;}});
map.on('click',function(e){if(Date.now()-(touchStart||0)<500)sendMsg('press',{lat:e.latlng.lat,lng:e.latlng.lng});});
sendMsg('ready',{});

map.on('dragstart',function(){if(isNavMode)userInteracted=true;});

function recenterMap(){userInteracted=false;if(lastNavLL){map.panTo(lastNavLL);if(map.getZoom()<17)map.setZoom(17);}}

function setNavView(heading,entering){
  var mapEl=document.getElementById('map'),btn=document.getElementById('recenterBtn');
  if(!entering){isNavMode=false;currentRotation=0;userInteracted=false;mapEl.style.transform='none';if(btn)btn.style.display='none';return;}
  isNavMode=true;if(btn)btn.style.display='flex';
  var target=-(heading||0),diff=target-currentRotation;
  while(diff>180)diff-=360;while(diff<-180)diff+=360;
  currentRotation+=diff;
  mapEl.style.transform='perspective(800px) rotateX(40deg) rotate('+currentRotation+'deg) scale(1.5)';
}

function setTileUrl(u,a){if(tileLayer)map.removeLayer(tileLayer);
  tileLayer=L.tileLayer(u,{attribution:a,maxZoom:19}).addTo(map);}

function updateMap(d){
  clearArr(markers);clearArr(polylines);
  var bounds=L.latLngBounds([]),hasBounds=false;

  /* Origin blue dot */
  if(d.origin&&!d.navLocation){
    var p=L.latLng(d.origin.lat,d.origin.lng);
    markers.push(L.circleMarker(p,{radius:8,fillColor:'#4285F4',fillOpacity:1,color:'#fff',weight:3}).bindTooltip('Your location').addTo(map));
    markers.push(L.circleMarker(p,{radius:3.5,fillColor:'#fff',fillOpacity:1,color:'#fff',weight:0}).addTo(map));
    bounds.extend(p);hasBounds=true;
  }
  /* Destination */
  if(d.destination){
    var dp=L.latLng(d.destination.lat,d.destination.lng);
    markers.push(L.marker(dp).bindTooltip('Destination').addTo(map));
    bounds.extend(dp);hasBounds=true;
  }

  /* Unselected routes */
  (d.routes||[]).forEach(function(r){if(r.selected)return;
    var ll=r.path.map(function(p){return[p.lat,p.lng];});
    var pl=L.polyline(ll,{color:'#98a2b3',opacity:.5,weight:5}).addTo(map);
    pl.on('click',function(){sendMsg('selectRoute',{id:r.id});});
    polylines.push(pl);bounds.extend(pl.getBounds());hasBounds=true;
  });

  function nearestIdx(path,pt){var best=0,bestD=1e18;
    for(var i=0;i<path.length;i++){var dl=path[i].lat-pt.lat,dn=path[i].lng-pt.lng,dd=dl*dl+dn*dn;if(dd<bestD){bestD=dd;best=i;}}return best;}

  /* Selected route */
  var sel=(d.routes||[]).find(function(r){return r.selected;});
  if(sel){
    if(d.navLocation&&sel.path.length>1){
      var np={lat:d.navLocation.lat,lng:d.navLocation.lng},si=nearestIdx(sel.path,np);
      if(si>0){var tp=[];for(var ti=0;ti<=si;ti++)tp.push([sel.path[ti].lat,sel.path[ti].lng]);tp.push([np.lat,np.lng]);
        polylines.push(L.polyline(tp,{color:'#1D2939',opacity:.7,weight:7}).addTo(map));}
      if(d.segments&&d.segments.length>0){
        d.segments.forEach(function(sg){var fp=[];var st=false;
          for(var i=0;i<sg.path.length;i++){var sp=sg.path[i];if(!st){var idx=nearestIdx(sel.path,sp);if(idx>=si)st=true;}
            if(st)fp.push([sp.lat,sp.lng]);}
          if(fp.length>=2)polylines.push(L.polyline(fp,{color:sg.color,opacity:.9,weight:7}).addTo(map));});
      }else{var rp=[[np.lat,np.lng]];for(var ri=si;ri<sel.path.length;ri++)rp.push([sel.path[ri].lat,sel.path[ri].lng]);
        polylines.push(L.polyline(rp,{color:'#4285F4',opacity:.85,weight:6}).addTo(map));}
    }else{
      if(d.segments&&d.segments.length>0){d.segments.forEach(function(sg){var sp=sg.path.map(function(p){return[p.lat,p.lng];});
        polylines.push(L.polyline(sp,{color:sg.color,opacity:.9,weight:7}).addTo(map));});
      }else{var sp2=sel.path.map(function(p){return[p.lat,p.lng];});
        polylines.push(L.polyline(sp2,{color:'#4285F4',opacity:.85,weight:6}).addTo(map));}
    }
    sel.path.forEach(function(p){bounds.extend(L.latLng(p.lat,p.lng));});hasBounds=true;
  }

  /* Safety markers */
  var mc={crime:'#ef4444',shop:'#22c55e',light:'#facc15',bus_stop:'#3b82f6',cctv:'#8b5cf6',dead_end:'#f97316'};
  var hl=d.highlightCategory||null;
  (d.safetyMarkers||[]).forEach(function(m){
    var k=m.kind||'crime';
    var isHl=hl&&hl===k;
    var isDim=hl&&hl!==k;
    if(isDim)return;
    var r=isHl?8:((k==='light'||k==='crime')?3:4);
    var op=isHl?1:0.85;
    var w=isHl?2:1;
    markers.push(L.circleMarker([m.lat,m.lng],{radius:r,fillColor:mc[k]||'#94a3b8',
      fillOpacity:op,color:'#fff',weight:w}).bindTooltip(m.label||k).addTo(map));
  });

  /* Road labels */
  (d.roadLabels||[]).forEach(function(l){var t=l.name.slice(0,12);
    var ic=L.divIcon({className:'',html:'<div class="road-label" style="background:'+l.color+'">'+t+'</div>',iconSize:null});
    markers.push(L.marker([l.lat,l.lng],{icon:ic,interactive:false}).addTo(map));});

  /* Fit bounds */
  if(d.fitBounds&&hasBounds&&!d.navLocation)map.fitBounds(bounds,{padding:[40,40],maxZoom:16});
  if(d.panTo){map.panTo([d.panTo.lat,d.panTo.lng]);if(map.getZoom()<14)map.setZoom(14);}

  /* Range circle */
  if(rangeCircle){map.removeLayer(rangeCircle);rangeCircle=null;}
  if(d.origin&&d.maxDistanceKm&&d.maxDistanceKm>0&&!d.navLocation){
    rangeCircle=L.circle([d.origin.lat,d.origin.lng],{
      radius:d.maxDistanceKm*1000,
      color:'#EF4444',weight:2.5,opacity:0.8,
      fillColor:'#EF4444',fillOpacity:0.04,
      dashArray:'8,6',
      interactive:false
    }).addTo(map);
  }

  /* Navigation arrow + 3D nav view */
  if(navMarker){map.removeLayer(navMarker);navMarker=null;}
  if(d.navLocation){var h=d.navHeading||0;
    lastNavLL=[d.navLocation.lat,d.navLocation.lng];
    var svg='<svg xmlns="http://www.w3.org/2000/svg" width="44" height="44" viewBox="0 0 44 44">'
      +'<circle cx="22" cy="22" r="19" fill="#1570EF" stroke="white" stroke-width="3"/>'
      +'<polygon points="22,7 29,27 22,22 15,27" fill="white" transform="rotate('+h+',22,22)"/></svg>';
    var ni=L.divIcon({className:'nav-arrow',
      html:'<img src="data:image/svg+xml;charset=UTF-8,'+encodeURIComponent(svg)+'" width="44" height="44"/>',
      iconSize:[44,44],iconAnchor:[22,22]});
    navMarker=L.marker(lastNavLL,{icon:ni,interactive:false,zIndexOffset:1000}).addTo(map);
    if(!userInteracted){map.panTo(lastNavLL);if(map.getZoom()<17)map.setZoom(17);}
    setNavView(h,true);
  }else{setNavView(0,false);}
}
<\/script>
</body></html>`;

// ─────────────────────────────────────────────────────────────────────────────
// React component — embeds Leaflet via an iframe blob on web
// ─────────────────────────────────────────────────────────────────────────────

export const RouteMap = ({
  origin,
  destination,
  routes,
  selectedRouteId,
  safetyMarkers = [],
  routeSegments = [],
  roadLabels = [],
  panTo,
  isNavigating = false,
  navigationLocation,
  navigationHeading,
  mapType = 'roadmap',
  highlightCategory,
  maxDistanceKm,
  onSelectRoute,
  onLongPress,
  onMapPress,
}: RouteMapProps) => {
  const iframeRef = useRef<HTMLIFrameElement | null>(null);
  const readyRef = useRef(false);
  const [hasError, setHasError] = useState(false);
  const prevGeoKeyRef = useRef('');
  const prevPanKeyRef = useRef(-1);
  const prevMapTypeRef = useRef(mapType);

  const callbacksRef = useRef({ onMapPress, onLongPress, onSelectRoute });
  callbacksRef.current = { onMapPress, onLongPress, onSelectRoute };

  // Listen for messages from the Leaflet iframe
  useEffect(() => {
    const handler = (event: MessageEvent) => {
      try {
        const msg = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;
        const cbs = callbacksRef.current;
        switch (msg.type) {
          case 'ready':
            readyRef.current = true;
            pushUpdate();
            break;
          case 'press':
            cbs.onMapPress?.({ latitude: msg.lat, longitude: msg.lng });
            break;
          case 'longpress':
            cbs.onLongPress?.({ latitude: msg.lat, longitude: msg.lng });
            break;
          case 'selectRoute':
            cbs.onSelectRoute?.(msg.id);
            break;
        }
      } catch { /* ignore */ }
    };

    window.addEventListener('message', handler);
    const custom = (e: Event) => handler({ data: (e as CustomEvent).detail } as MessageEvent);
    window.addEventListener('leaflet-msg', custom);
    return () => { window.removeEventListener('message', handler); window.removeEventListener('leaflet-msg', custom); };
  }, []);

  const pushUpdate = () => {
    if (!readyRef.current || !iframeRef.current?.contentWindow) return;
    const toLL = (c: { latitude: number; longitude: number }) => ({ lat: c.latitude, lng: c.longitude });

    const mappedRoutes = routes.map((r) => ({
      id: r.id,
      selected: r.id === selectedRouteId,
      path: r.path.map(toLL),
    }));
    const segments = routeSegments.map((seg) => ({ color: seg.color, path: seg.path.map(toLL) }));
    const mkrs = safetyMarkers.map((m) => ({
      kind: m.kind, label: m.label,
      lat: m.coordinate.latitude, lng: m.coordinate.longitude,
    }));
    const labels = roadLabels.map((l) => ({
      name: l.displayName, color: l.color,
      lat: l.coordinate.latitude, lng: l.coordinate.longitude,
    }));

    const geoKey = [
      origin ? `${origin.latitude},${origin.longitude}` : '',
      destination ? `${destination.latitude},${destination.longitude}` : '',
      routes.map((r) => r.id).join(','),
      selectedRouteId ?? '',
    ].join('|');
    const fitBounds = geoKey !== prevGeoKeyRef.current;
    if (fitBounds) prevGeoKeyRef.current = geoKey;

    let panToData: { lat: number; lng: number } | null = null;
    if (panTo && panTo.key !== prevPanKeyRef.current) {
      prevPanKeyRef.current = panTo.key;
      panToData = toLL(panTo.location);
    }

    const payload = {
      origin: origin ? toLL(origin) : null,
      destination: destination ? toLL(destination) : null,
      routes: mappedRoutes,
      segments,
      safetyMarkers: mkrs,
      roadLabels: labels,
      fitBounds,
      panTo: panToData,
      navLocation: isNavigating && navigationLocation ? toLL(navigationLocation) : null,
      navHeading: navigationHeading,
      highlightCategory: highlightCategory || null,
      maxDistanceKm: maxDistanceKm || null,
    };

    try {
      const win = iframeRef.current.contentWindow as any;
      if (win.updateMap) win.updateMap(payload);
    } catch { /* cross-origin */ }
  };

  // Push when props change
  useEffect(() => { pushUpdate(); }, [
    origin, destination, routes, selectedRouteId,
    safetyMarkers, routeSegments, roadLabels, panTo,
    isNavigating, navigationLocation, navigationHeading,
    highlightCategory, maxDistanceKm,
  ]);

  // Switch tile layer on mapType change
  useEffect(() => {
    if (!readyRef.current || !iframeRef.current?.contentWindow) return;
    if (mapType === prevMapTypeRef.current) return;
    prevMapTypeRef.current = mapType;
    try {
      const win = iframeRef.current.contentWindow as any;
      if (win.setTileUrl) win.setTileUrl(TILE_URLS[mapType], TILE_ATTR[mapType]);
    } catch { /* ignore */ }
  }, [mapType]);

  // Blob URL for iframe src
  const [blobUrl, setBlobUrl] = useState<string | null>(null);
  useEffect(() => {
    const blob = new Blob([buildLeafletHtml()], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    setBlobUrl(url);
    return () => URL.revokeObjectURL(url);
  }, []);

  return (
    <View style={styles.container}>
      {blobUrl ? (
        <iframe
          ref={iframeRef as any}
          src={blobUrl}
          style={{ width: '100%', height: '100%', border: 'none', position: 'absolute', top: 0, left: 0 }}
          title="Map"
          onError={() => setHasError(true)}
        />
      ) : null}
      {hasError ? (
        <View style={styles.placeholder}>
          <Text style={styles.placeholderText}>Map unavailable</Text>
        </View>
      ) : null}
      <View style={styles.attribution}>
        <Text style={styles.attributionText}>© OpenStreetMap contributors</Text>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#f2f4f7' },
  placeholder: { flex: 1, alignItems: 'center', justifyContent: 'center' },
  placeholderText: { color: '#667085', fontSize: 14 },
  attribution: {
    position: 'absolute', right: 8, bottom: 8,
    paddingHorizontal: 8, paddingVertical: 4,
    borderRadius: 6, backgroundColor: 'rgba(255,255,255,0.9)',
  },
  attributionText: { fontSize: 10, color: '#475467' },
});

export default RouteMap;
